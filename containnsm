#!/usr/bin/env bash
COWSAY=/usr/games/cowsay
LOGFILE=containnsm.log

# Globals
ARGC=$#
SUBCOMMAND="$1"
shift 1
ARGV="$@"
PARAMS="${ARGV%%--*}"
CMDLINE="${ARGV#*--}"
REPO=opennsm

normal="$(tput sgr0)"
bold="$(tput bold)"
underline="$(tput smul)"
yellow="$(tput setaf 3)"
redf="$(tput setaf 1)"
magentaf="$(tput setaf 5)"
whitef="$(tput setaf 7)"

N="${normal}"
B="${bold}"
U="${underline}"
Y="${yellow}"
RF="${redf}"
RB="${redb}"
GF="${greenf}"
GB="${greenb}"
MF="${magentaf}"
WF="${whitef}"

usage(){
cat <<EOF

${MF}ContainNSM:${N} ${Y}Easily utilize the ContainNSM docker image collection${N}

      ${B}Subcommands:${N}
        ${Y}help${N}            Help (this message)
        ${Y}build${N}           Build an image from directory
        ${Y}list${N}            List images in repository
        ${Y}listinstalled${N}   List installed images
        ${Y}run${N}             Create a container from image
        ${Y}grouprun${N}        Create a group of containers

      ${B}Subcommand options:${N}
        build ${U}<dir>${N}                Directory to Dockerfile
        help                       Help
        list|listinstalled ${U}[<dir>]${N} List available images by tool
        run|grouprun ${U}[options]${N}
          ${WF}-i${N}                       Share network interfaces with host
          ${WF}-r${N} ${U}<file>${N}                Read in file, mostly PCAP (Mounts in container)
          ${WF}-w${N} ${U}<dir|file>${N}            Write out data to directory or file
          ${WF}-C${N} ${U}<dir>${N}                 Set working directory in container
          ${WF}-I${N} ${U}<image>${N}               Docker image e.g. \`\`-I bro:2.4.1''
          ${WF}--${N}                       Arguments passed to container e.g. \`\`-- bash''

      ${B}Examples:${N}
            $0 build bro/2.4.1
            $0 run -r /pcaps/ctf.pcap -I tcpdump:4.7.4 -- tcpdump -nr ctf.pcap -c 10
            $0 run -w \$PWD -C \$PWD  -I bro:2.4 -- bro -i eth0
            $0 run -I tcpdump -i -- tcpdump -ni docker0
            $0 grouprun -r \$PWD/ctf.pcap -I tcpdump -- tcpdump -nr ctf.pcap -c 1 udp

${Y}Usage:${N} ${MF}$0${N} ${WF}sub${N} {${Y}-I${N} ${WF}image${N}} [${Y}-r${N} ${WF}pcap${N}] [${Y}-w${N} ${WF}dir|file${N}] -- [${WF}commands${N}]
EOF
exit 1
}

function die(){
  if [ -f ${COWSAY:-none} ]; then
    $COWSAY -d "$*"
  else
    echo "${RF}$*${N}"
  fi
  exit 1
}

function hi(){
  if [ -f ${COWSAY:-none} ]; then
    $COWSAY "$*"
  else
    echo "${WF}$*${N}"
  fi
  return 0
}

argcheck(){
  local num
  num="$1"
  [[ $ARGC -lt $num ]] && die "Missing arguments! Use \`\`$0 help'' for help."
}

trap 'die "Trap recieved, exiting...";' 1 2 3 20

options(){
  # Check for arguments
  argcheck 1

  [[ "$SUBCOMMAND" == "help"     ]]      && usage
  [[ "$SUBCOMMAND" == "build"    ]]      && build "$PARAMS" && exit 0
  [[ "$SUBCOMMAND" == "list"     ]]      && list  "$PARAMS" && exit 0
  [[ "$SUBCOMMAND" == "listinstalled" ]] && listinstalled "$PARAMS" && exit 0

  if [[ "$SUBCOMMAND" =~ run|grouprun ]]; then
    while getopts "hC:ir:I:w:" OPTION $PARAMS
    do
      case $OPTION in
        h) usage;;
        C) WORKDIR="$OPTARG";;
        i) NET="true";;
        r) PCAP="$OPTARG";;
        w) WRITE=1; OUT="$OPTARG";;
        I) IMAGE="${REPO}/${OPTARG}";;
        \?) die "Invalid option: -$OPTARG" >&2;;
      esac
    done
    return 0
  fi
  die "Invalid option, please see help for subcommands: \`\`$0 help''"
}

is_docker(){
  which docker 1>/dev/null 2>/dev/null || die "Docker not found, check PATH"
}

is_pcap(){
  local pcap
  local is_pcap
  pcap="$1"

  # Read option not used
  [[ $pcap == "none" ]] && return 0

  # Test for valid PCAP
  [[ -f $pcap ]] || die "File $pcap not found or not file"
  is_pcap=$(file $pcap 2>/dev/null)
  [[ "$is_pcap" =~ "tcpdump capture file" ]] || hi "Not a valid PCAP file..maybe this was intentional" >&2
  return 0
}

test_paths(){
  printf "${Y}Mount:${N} ${WF}Host: ${N}%s\n    ${MF}->${N} ${WF}Container: ${N}%s\n" "$OUT" "$OUT"  >&2
  printf "${Y}Cwd:${N}\t%s\n" "$WORKDIR" >&2
  printf "${Y}HostNet:${N}%6s\n" "${NET}" >&2
  printf "${Y}PCAP:${N}\t%s\n" "$PCAP" >&2

  [[ "$OUT"     = /* ]]     || die "Error: $OUT is not an absolute path!"
  [[ "$WORKDIR" = /* ]]     || die "Error: $workdir is not an absolute path!"
  [[ "$PCAP"    = "none" ]] && return 0
  [[ "$PCAP"    = /* ]]     || die "Error: $pcap is not an absolute path!"
  return 0
}

config(){
  local cwd
  home=/home/${REPO}
  OUT="${OUT:-$PWD}"
  PCAP="${PCAP:-none}"
  [[ "$PCAP" = "none" ]] || PCAP_DIR=$(dirname "$PCAP")
  WORKDIR="${WORKDIR:-$PCAP_DIR}"
  [[ $WORKDIR ]] || WORKDIR="$PWD"
  ! [[ "$WRITE" -eq 1 ]] && [[ "$PCAP" = "none" ]] && WORKDIR="$home"
  [[ "$NET" == "true" ]] || NET="false"
}

is_repo(){
  [[ -f "$PWD"/.git/config ]] || die "You run $0 from containsnm repo"
}

is_dir(){
  local dir
  local print
  dir="$1"
  if [[ "$dir" ]]; then
    [[ -d "$dir" ]] || die "Tool directory $dir doesn't exist"
  fi
}


list(){
  local dir
  local print
  dir="${1%/}"
  print="$2"
  is_dir "$dir"
  [[ "$SUBCOMMAND" == "list" ]] && printf "Repo/Image:Tag%32s\n" "Dir/Dir" >&2
  for image in ${dir:-*}/*
  do
    ! [[ $print ]] && printf "opennnsm/${image/\//:}%30s\n" "$image"
    [[ $print ]] && printf "opennnsm/${image/\//:}\n"
  done
  return 0
}

listinstalled(){
  local tool
  tool="${1%/}"
  if [[ $tool ]]; then
    docker images -f "label=program=$tool" 
  else
    docker images -f "label=organization=$REPO" 
  fi
}

build(){
  local file
  local image
  local tag
  dir=$1
  [[ -d $dir ]] || die "$dir is not a directory or doesn't exist"
  [[ $dir = */*/* ]] && dir=${dir%/*}
  image="${dir%/*}"
  tag="${dir#*/}"
  name="${image}:${tag}"
  docker build -t ${REPO}/${name} - < $dir/Dockerfile
  [[ $? -ne 0 ]] && die "Build failed, check your Dockerfile"
  hi "Image created - try \`\`${MF}./containnsm run -I ${REPO}/${name} -- bash${N}'' to test it out"
  return 0
}

is_image(){
  local image
  image="$1"
  [[ "${image}" ]] || die "No image specified, try \`\`-I <image>''"
}

run(){
  local pcap
  local cmdline
  local image
  pcap="$1"
  cmdline="$2"
  image="$3"
  [[ "$ARGV" =~ '--' ]] || die "Error: Missing container arguments e.g. \`\`$0 ... -- bash''"
  [[ "$NET" == "true" ]] && NET="--net=host" || unset NET
  printf "${Y}Image:${N}\t%s\n" "${image:-$IMAGE}" >&2
  [[ $pcap = "none" ]] && eval docker run -it "$NET" -v "${OUT}:${OUT}:rw" -w "$WORKDIR" "${IMAGE:-$image}" "$cmdline"
  [[ $pcap != "none" ]] && eval docker run -it "$NET" -v "${pcap}:${pcap}:ro" -v "${OUT}:${OUT}:rw" -w "$WORKDIR" "${IMAGE:-$image}" "$cmdline"
}

grouprun(){
  group=$(list "${IMAGE/opennsm\//}" "listrepo")
  printf "${WF}I will attempt to pull missing images...${N}\n" >&2
  for image in $group; do
    run "${PCAP}" "$CMDLINE" "$image"
  done
}

main(){
  # Check if we're in repo
  is_repo
  options
  # Test if image was given
  is_image "$IMAGE"
  config
  # Check for absolute paths
  test_paths
  # Check for Docker
  is_docker
  # Check input file
  [[ $PCAP ]] && is_pcap "${PCAP}"
  [[ "$SUBCOMMAND" == "run" ]] && run "${PCAP}" "$CMDLINE"
  [[ "$SUBCOMMAND" == "grouprun" ]] && grouprun "$PARAMS"
}

main
