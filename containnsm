#!/usr/bin/env bash
COWSAY=$(which cowsay 2>/dev/null)
LOGFILE=containnsm.log

# Globals
ARGC=$#
SUBCOMMAND="$1"
shift 1
ARGV="$@"
PARAMS="${ARGV%%--*}"
CMDLINE="${ARGV#*--}"
REPO=opennsm
USER=opennsm

normal="$(tput sgr0)"
bold="$(tput bold)"
underline="$(tput smul)"
yellow="$(tput setaf 3)"
redf="$(tput setaf 1)"
magentaf="$(tput setaf 5)"
whitef="$(tput setaf 7)"

N="${normal}"
B="${bold}"
U="${underline}"
Y="${yellow}"
RF="${redf}"
RB="${redb}"
GF="${greenf}"
GB="${greenb}"
MF="${magentaf}"
WF="${whitef}"

usage(){
cat <<EOF

${MF}ContainNSM:${N} ${Y}Easily utilize the ContainNSM docker image collection${N}

      ${B}Subcommands:${N}
        ${Y}help${N}            Help (this message)
        ${Y}new${N}             Create new directory with Dockerfile template
        ${Y}build${N}           Build an image from version directory
        ${Y}groupbuild${N}      Build all image versions from tool directory
        ${Y}list${N}            List images in repository
        ${Y}listinstalled${N}   List installed images
        ${Y}run${N}             Create a container from image
        ${Y}grouprun${N}        Create a group of containers
        ${Y}last${N}            Attach to most recently used image with shell

      ${B}Subcommand options:${N}
        new ${U}<dir>${N}                  Directory to create
        build|groupbuild ${U}<dir>${N}     Directory to Dockerfile
        help                       Help
        list|listinstalled ${U}[<dir>]${N} List available images by tool
        run|grouprun ${U}[options]${N}
          ${WF}-i${N}                       Share network interfaces with host
          ${WF}-r${N} ${U}<file>${N}                Read in file, mostly PCAP (Mounts in container)
          ${WF}-w${N} ${U}<dir|file>${N}            Write out data to directory or file
          ${WF}-u${N} ${U}<user>${N}                User in container (def: opennsm)
          ${WF}-C${N} ${U}<dir>${N}                 Set working directory in container
          ${WF}-I${N} ${U}<image>${N}               Docker image e.g. \`\`-I bro:2.4.1''
          ${WF}--${N} ${U}[command..]${N}           Arguments passed to container e.g. \`\`-- bash''

      ${B}Examples:${N}
            $0 build bro/2.4.1
            $0 run -I tcpdump:4.7.4 -r /pcaps/ctf.pcap -- tcpdump -nr ctf.pcap -c 10
            $0 run -I tcpdump -i -- tcpdump -ni eth0

${B}Usage:${N} ${MF}$0${N} ${Y}sub${N} [ { ${U}dir${N} } | [{${WF}-I${N} ${U}image${N}} [${WF}-r${N} ${U}pcap${N}] [${WF}-w${N} ${U}dir|file${N}] -- [${U}command${N}]]]
EOF
exit 1
}

die(){
  if [ -f ${COWSAY:-none} ]; then
    $COWSAY -d "$*" >&2
  else
    printf "${RF}$*${N}\n" >&2
  fi
  exit 1
}

hi(){
  if [ -f ${COWSAY:-none} ]; then
    $COWSAY "$*" >&2
  else
    printf "${WF}$*${N}\n" >&2
  fi
  return 0
}

argcheck(){
  local num
  num="$1"
  [[ $ARGC -lt $num ]] && die "Missing arguments! Use \`\`$0 help'' for help."
}

trap 'die "Trap recieved, exiting...";' 1 2 3 20

options(){
  # Check for arguments
  argcheck 1

  [[ "$SUBCOMMAND" == "help"          ]] && usage
  [[ "$SUBCOMMAND" == "new"           ]] && new "$PARAMS" && exit 0
  [[ "$SUBCOMMAND" == "build"         ]] && build "$PARAMS" && exit 0
  [[ "$SUBCOMMAND" == "groupbuild"    ]] && groupbuild "$PARAMS" && exit 0
  [[ "$SUBCOMMAND" == "list"          ]] && list  "$PARAMS" && exit 0
  [[ "$SUBCOMMAND" == "listinstalled" ]] && listinstalled "$PARAMS" && exit 0
  [[ "$SUBCOMMAND" == "last"          ]] && last && exit 0

  if [[ "$SUBCOMMAND" =~ run|grouprun ]]; then
    while getopts "hC:ir:I:w:u:" OPTION $PARAMS
    do
      case $OPTION in
        h) usage;;
        C) WORKDIR="$OPTARG";;
        i) NET="true";;
        r) PCAP="$OPTARG";;
        u) USER="$OPTARG";;
        w) WRITE=1; OUT="$OPTARG";;
        I) IMAGE="${OPTARG}";;
        \?) die "Invalid option: -$OPTARG" >&2;;
      esac
    done
    return 0
  fi
  die "Invalid option, please see help for subcommands: \`\`$0 help''"
}

is_docker(){
  which docker 1>/dev/null 2>/dev/null || die "Docker not found, check PATH"
}

is_pcap(){
  local pcap
  local is_pcap
  pcap="$1"

  # Read option not used
  [[ $pcap == "none" ]] && return 0

  # Test for valid PCAP
  [[ -f $pcap ]] || die "File $pcap not found or not file"
  is_pcap=$(file $pcap 2>/dev/null)
  [[ "$is_pcap" =~ "tcpdump capture file" ]] || hi "Not a valid PCAP file..maybe this was intentional" >&2
  return 0
}

test_paths(){
  printf "${Y}Mount:${N} ${WF}Host: ${N}%s\n    ${MF}->${N} ${WF}Container: ${N}%s\n" "$OUT" "$OUT"  >&2
  printf "${Y}Cwd:${N}\t%s\n" "$WORKDIR" >&2
  printf "${Y}HostNet:${N}%6s\n" "${NET}" >&2
  printf "${Y}PCAP:${N}\t%s\n" "$PCAP" >&2

  [[ "$OUT"     = /* ]]     || die "Error: $OUT is not an absolute path!"
  [[ "$WORKDIR" = /* ]]     || die "Error: $workdir is not an absolute path!"
  [[ "$PCAP"    = "none" ]] && return 0
  [[ "$PCAP"    = /* ]]     || die "Error: $pcap is not an absolute path!"
  return 0
}

config(){
  local cwd
  home=/home/${REPO}
  OUT="${OUT:-$PWD}"
  PCAP="${PCAP:-none}"
  [[ "$PCAP" = "none" ]] || PCAP_DIR=$(dirname "$PCAP")
  WORKDIR="${WORKDIR:-$PCAP_DIR}"
  [[ $WORKDIR ]] || WORKDIR="$PWD"
  ! [[ "$WRITE" -eq 1 ]] && [[ "$PCAP" = "none" ]] && WORKDIR="$home"
  [[ "$NET" == "true" ]] || NET="false"
}

is_repo(){
  local sub
  sub="$1"
  [[ -f "$PWD"/.git/config ]] || die "$0 $sub must be run from containsnm repo"
}

is_dir(){
  local dir
  local print
  dir="$1"
  if [[ "$dir" ]]; then
    [[ -d "$dir" ]] || die "Tool directory $dir doesn't exist"
  fi
}


list(){
  local dir
  local print
  is_repo $FUNCNAME
  dir="${1%/}"
  print="$2"
  is_dir "$dir"
  [[ "$SUBCOMMAND" == "list" ]] && printf "Repo/Image:Tag%32s\n" "Dir/Dir" >&2
  for image in ${dir:-*}/*
  do
    ! [[ $print ]] && printf "opennsm/${image/\//:}%30s\n" "$image"
    [[ $print ]] && printf "opennsm/${image/\//:}\n"
  done
  return 0
}

listinstalled(){
  local tool
  tool="${1%/}"
  if [[ $tool ]]; then
    docker images -f "label=program=$tool" 
  else
    docker images -f "label=organization=$REPO" 
  fi
}

build(){
  local file
  local image
  local tag
  is_repo $FUNCNAME
  dir=$1
  [[ -d $dir ]] || die "$dir is not a directory or doesn't exist"
  [[ $dir = */*/* ]] && dir=${dir%/*}
  image="${dir%/*}"
  tag="${dir#*/}"
  name="${image}:${tag}"
  docker build -t ${REPO}/${name} - < $dir/Dockerfile
  [[ $? -ne 0 ]] && die "Build failed, check your Dockerfile"
  hi "Image created - try \`\`${MF}./containnsm run -I ${name} -- bash${N}'' to test it out"
  return 0
}

groupbuild(){
  local dir
  local version
  dir="${1%/*}"
  [[ -d "$dir" ]] || die "$dir is not a tool directory or doesn't exist"
  for version in $dir/*;
  do
    [[ -d "$version" ]] && build $version
  done
  hi "$FUNCNAME complete"
}

is_image(){
  local image
  image="$1"
  [[ "${image}" ]] || die "No image specified, try \`\`-I <image>''"
}

format_image(){
  image=${image//opennsm\/}  # Remove repo if given, we add it below
  image="${image/\//:}"      # Put path in Docker image format by sub last / with :
  image=${image%/}           # Remove any trailing forward slash
  image=${image%:}           # Remove any trailing colons
  ## Find the latest image version when latest is assumed because no tag
  { [[ "$image" =~ latest ]] || ! [[ "$image" =~ :|/ ]]; } &&  latest "$image"
  image="$REPO/$image"       # opennsm + '/' + $image
}

run(){
  local pcap
  local cmdline
  local image
  local correct_format
  local image_name_contains_opennsm
  local non_opennsm_image_specified
  correct_image_format=0
  image_name_contains_opennsm=0
  non_opennsm_image_specified=0
  pcap="$1"
  cmdline="$2"
  image="${3:-$IMAGE}"       # Satisfy image presence when grouprun()

  # Be friendly by supporting different ways to specify the image e.g.
  # -I bro
  # -I bro:latest
  # -I opennsm/bro
  # -I opennsm/bro:latest
  # -I opennsm/bro/latest
  # This happens when format_image() is called otherwise friendliness doesn't apply

  [[ "$image" =~ [a-z0-9_.-]+/[a-z0-9_.-]+:[a-z0-9_.-] ]] && correct_image_format=1
  [[ "$image" =~ opennsm ]] && image_name_contains_opennsm=1
  [[ $correct_image_format -eq 1 ]] && [[ $image_name_contains_opennsm -eq 0 ]] && non_opennsm_image_specified=1
  [[ $non_opennsm_image_specified -eq 1 ]] || format_image

  # Make sure arguments are passed to the container
  [[ "$ARGV" =~ '--' ]] || die "Error: Missing container arguments e.g. \`\`$0 ... -- bash''"
  # Use the host network if -i was specified
  [[ "$NET" == "true" ]] && NET="--net=host" || unset NET
  # Setup custom options for some images that require them to be useful
  run_options "$image" || unset $OPTS

  # Create container
  printf "${Y}Image:${N}\t%s %s\n" "$image" "$latest" >&2
  [[ $pcap = "none" ]] && eval docker run -it --rm "$OPTS" "$NET" -u "$USER" -v "${OUT}:${OUT}:rw" -w "$WORKDIR" "$image" "$cmdline" 
  [[ $pcap != "none" ]] && eval docker run -it --rm "$OPTS" "$NET" -u "$USER" -v "${pcap}:${pcap}:ro" -v "${OUT}:${OUT}:rw" -w "$WORKDIR" "$image" "$cmdline"
}

run_options(){
  local image
  image="$1"
  # Some images require specific settings, set them here
  [[ "$image" =~ 'netsniff-ng' ]] && OPTS="--privileged=true"
  [[ "$OPTS" ]] || return 0
}

latest(){
  local name
  name="${1%:*}"    # Trim trailing colon
  name="${name#*/}" # Trim organization

  # Only sort on versioned numbered tool directories
  [[ "$name" =~ debian ]] && return 0

  # Skip this whole thing if we're not in the repo
  if [[ -f "$PWD"/.git/config ]]; then
    # If tool directory doesn't exist then don't get latest version
    if [[ -d $name ]]; then
      cd $name
      latest=$(for dir in *; do printf "$dir\n"; done | tail -n 1)
      cd $OLDDIR
      image="$name:$latest"
      latest="(${WF}latest${N})"
    fi
  fi
}

grouprun(){
  local image
  image="${IMAGE}"
  image="${image%:*}"
  image="${image%%/*}"
  group=$(list "${image/opennsm\//}" "listrepo")
  printf "${WF}I will attempt to pull missing images...${N}\n" >&2
  for tool in $group; do
    run "${PCAP}" "$CMDLINE" "${tool#*/}"
  done
  hi "$FUNCNAME complete"
}

template(){
  local dir
  dir="$1"
  hi "Replace :TEXT: at $dir placeholders with your settings"
cat <<EOF
# :TOOL: :VERSION:
#
# VERSION 0.1
FROM      opennsm/debian
MAINTAINER :FIRST: :LAST: <:EMAIL:>

# Metadata
LABEL organization=opennsm
LABEL program=:TOOL:

# Specify container username e.g. training, demo
ENV VIRTUSER opennsm
# Specify program
ENV PROG :TOOL:
# Specify source extension
ENV EXT tar.gz
# Specify Bro version to download and install (e.g. tool-2.3.1)
ENV VERS :VERSION:
# Install directory
ENV PREFIX /opt/:TOOL:
# Path should include prefix
ENV PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:\$PREFIX/bin

# Install dependencies
RUN apt-get update -qq
RUN apt-get install -yq :DEPENDENCIES: --no-install-recommends

# Compile and install tool
USER \$VIRTUSER
WORKDIR /home/\$VIRTUSER
RUN wget --no-check-certificate https://www.:TOOL:.org/downloads/\$PROG-\$VERS.\$EXT && tar -xzf \$PROG-\$VERS.\$EXT
WORKDIR /home/\$VIRTUSER/\$PROG-\$VERS
RUN ./configure --prefix=\$PREFIX && make
USER root
RUN make install
RUN chmod u+s \$PREFIX/bin/\$PROG

# Cleanup
RUN rm -rf /home/\$VIRTUSER/\$PROG-\$VERS

# Environment
WORKDIR /home/\$VIRTUSER
USER opennsm
EOF
}

new(){
  local dir
  dir="$1"
  [[ -d "$dir" ]] && die "Tool directory $dir already exists"
  mkdir -p "$PARAMS" || die "Error creating $dir directory"
  template "$dir" > $PARAMS/Dockerfile || { rmdir -p $PARAMS && die "Template generation failed"; }
}

last(){
  local image
  is_docker
  image=$(docker images -q | head -n 1)
  docker run -it "$image" bash || return 1
}

main(){
  options
  # Test if image was given
  is_image "$IMAGE"
  config
  # Check for absolute paths
  test_paths
  # Check for Docker
  is_docker
  # Check input file
  [[ $PCAP ]] && is_pcap "${PCAP}"
  [[ "$SUBCOMMAND" == "run" ]] && run "${PCAP}" "$CMDLINE"
  [[ "$SUBCOMMAND" == "grouprun" ]] && grouprun "$PARAMS"
}

main
